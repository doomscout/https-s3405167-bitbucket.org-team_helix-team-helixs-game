using UnityEngine;
using System.Collections;

public static class ShapeInt {
	public const int P = -1;	//Player symbol
	public const int M = -2;	//Mouse symbol
	public static readonly int[,] singleShape = new int[1,1]{	{M} };
	public static readonly int[,] circleShape = new int[5,5]{	{0, 0, 0, 0, 0},
																{0, 0, 1, 0, 0},
																{0, 1, M, 1, 0},
																{0, 0, 1, 0, 0},
																{0, 0, 0, 0, 0}
															};
	public static readonly int[,] lineShape = new int[1,7]{	{P, 1, 1, 1, 1, 1, 1} };
	
	public static readonly int[,] coneShape = new int[5,5]{	{0, 0, 0, 0, 1},
															{0, 0, 0, 1, 1},
															{P, 1, 1, 1, 1},
															{0, 0, 0, 1, 1},
															{0, 0, 0, 0, 1}
														};
	

	public static int[,] GeneratePCGShapeFourMirror() {
		int[,] test = new int[5,5];
		int x = 2;
		int y = 2;
		int newX;
		int newY;
		int count = 0;
		int num = Random.Range (1, 4);

		while (count < num) {
			newX = x + Random.Range(-1, 2);
			newY = y + Random.Range(-1, 2);
			if (newX < 2 || newY < 2 ||
			    newX > 4 || newY > 4) {
				continue;
			}
			if (test[newX, newY] == 1) {
				continue;
			}
			test[newY, newX] = 1;
			x = newX;
			y = newY;
			count++;
		}


		for (int i = 2; i <= 4; i++) {
			for (int j = 2; j <= 4; j++) {
				test[i,4-j] = test[i,j];
			}
		}

		for (int i = 2; i <= 4; i++) {
			for (int j = 0; j <= 4; j++) {
				test[4-i,j] = test[i,j];
			}
		}

		test[2,2] = M;
		return test;
	}

	//algorithm: generate middle row (core) and use the left over tiles to
	//generate one side, then mirror for symmetry.
	//one side is generated by placing one seed tile and building on that seed 
	//tile randomly
	public static int[,] GeneratePCGShapeMirror() {
		int[,] test = new int[5,10];
		int numtiles = Random.Range(5, 20);
		int core = Random.Range(1, test.GetLength(1) - 1);
		
		if (core % 2 == 1) {
			core++;
		}
		numtiles -= core;
		numtiles /= 2;
		
		test[2,0] = P;
		int r = Random.Range(0, core+1);
		for (int i = 1; i < core+1; i++) {
			test[2,i] = 1;
		}
		test[1,r] = 1;
		numtiles--;
		int debugCount = 0;
		while (numtiles > 0) {
			int row = Random.Range (0, 2);
			if (Random.Range(0, 2) == 0) {
				//left ro right
				for (int i = 0; i < test.GetLength(1); i++) {
					if (test[row,i] == 0) {
						if (i == r || (i + 1 < test.GetLength(1) && test[row,i+1] == 1)) {
							test[row, i] = 1;
							numtiles--;
						}
					}
				}
			} else {
				//right to left
				for (int i = test.GetLength(1) - 1; i >= 0; i--) {
					if (test[row,i] == 0) {
						if (i == r || ( i - 1 >= 0 && test[row,i-1] == 1)) {
							test[row, i] = 1;
							numtiles--;
						}
					}
				}
			}
			if (debugCount++ > 1000) {
				Debug.LogError ("Overflow");
				return null;
			}
		}
		for (int i = 0; i < test.GetLength(0); i++) {
			for (int j = 0; j < test.GetLength(1); j++) {
				if (test[i,j] == 1) {
					test[test.GetLength(0)- 1 - i, j] = 1;
				}
			}
		}
		return test;
	}
	
	//algorithm: move one square at a time and if it's not marked, mark it
	public static int[,] GeneratePCGShapeRandom() {
		int[,] test = new int[5,10];
		int numTiles = 15;
		int ranX = 1;
		int ranY = 2;
		bool validMove;
		
		test[2,0] = P;
		
		while (numTiles >= 0) {
			validMove = false;
			if (test[ranY,ranX] == 0) {
				test[ranY,ranX] = 1;
				numTiles--;
			}
			do {
				Direction move = (Direction)Random.Range(1, 4);
				int oldX = ranX;
				int oldY = ranY;
				validMove = true;
				switch (move) {
				case Direction.Down:
					ranY--;
					break;
				case Direction.Up:
					ranY++;
					break;
				case Direction.Left:
					ranX--;
					break;
				case Direction.Right:
					ranX++;
					break;
				}
				if (ranY < 0 || ranY > 4 ||
				    ranX < 1 || ranX > 9) {
					ranX = oldX;
					ranY = oldY;
					validMove = false;
				}
			} while (!validMove);
		}
		Debug.Log("Made shape");
		return test;
	}
}
